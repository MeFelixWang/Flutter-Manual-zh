(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{164:function(t,_,r){"use strict";r.r(_);var e=r(0),v=Object(e.a)({},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),r("p",[t._v("在多点触控设备上，可以同时发生多次拖动，因为可能会有多个指针同时与设备接触。要限制同时拖动的数量，可以使用 maxSimultaneousDrags 属性。默认设置是允许无限数量的同时拖动。")]),t._v(" "),r("p",[t._v("当发生拖动时显示 child 中的组件。如果 childWhenDragging 非 null， 则显示 childWhenDragging 中的组件。")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),r("p",[t._v("长按使其子组件可以拖动。")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),r("p",[t._v("用于检测手势的组件。")]),t._v(" "),r("p",[t._v("会根据其非 null 的回调函数检测手势。")]),t._v(" "),r("p",[t._v("如果有子组件，则适应子组件的大小。否则，适应父组件的大小。")]),t._v(" "),r("p",[t._v("默认情况下，带有不可见子组件的 GestureDetector 会忽略触摸；可以通过 behavior 控制。")]),t._v(" "),r("p",[t._v("GestureDetector 也会监听辅助功能事件（accessibility events），并将它们映射到回调函数。要忽略辅助功能事件，可以将 excludeFromSemantics 设为 true。")]),t._v(" "),r("p",[t._v("有关其他信息，请参阅 "),r("a",{attrs:{href:"http://flutter.io/gestures/",target:"_blank",rel:"noopener noreferrer"}},[t._v("flutter.io/gestures/"),r("OutboundLink")],1),t._v("。")]),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12)])},[function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"draggable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#draggable","aria-hidden":"true"}},[this._v("#")]),this._v(" Draggable")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("可以在"),_("a",{attrs:{href:"#DragTarget"}},[this._v("DragTarget")]),this._v("中拖动的组件。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("当一个可拖动组件发生拖动时，它会显示一个在屏幕上跟踪用户手指的 feedback 组件。如果用在 "),_("a",{attrs:{href:""}},[this._v("DragTarget")]),this._v(" 组件上抬起手指，则该 "),_("a",{attrs:{href:""}},[this._v("DragTarget")]),this._v(" 可以选择接收 Draggable 组件携带的数据。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("affinity")]),t._v(" "),r("td",[t._v("控制此组件如何与其他手势竞争以启动拖动")])]),t._v(" "),r("tr",[r("td",[t._v("axis")]),t._v(" "),r("td",[t._v("如果指定，则限制拖动的轴向")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("包含的子组件")])]),t._v(" "),r("tr",[r("td",[t._v("childWhenDragging")]),t._v(" "),r("td",[t._v("拖动时显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("data")]),t._v(" "),r("td",[t._v("携带的数据")])]),t._v(" "),r("tr",[r("td",[t._v("dragAnchor")]),t._v(" "),r("td",[t._v("拖动时如何锚定此组件的位置")])]),t._v(" "),r("tr",[r("td",[t._v("feedback")]),t._v(" "),r("td",[t._v("拖动时指针下显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("feedbackOffset")]),t._v(" "),r("td",[t._v("可用于设置命中测试目标点，以便找到拖动目标。在 feedback 与 child 的相对位置改变时特别有用")])]),t._v(" "),r("tr",[r("td",[t._v("ignoringFeedbackSemantics")]),t._v(" "),r("td",[t._v("在构建语义树时是否忽略 feedback 组件的语义")])]),t._v(" "),r("tr",[r("td",[t._v("maxSimultaneousDrags")]),t._v(" "),r("td",[t._v("支持多少个同时拖动")])]),t._v(" "),r("tr",[r("td",[t._v("onDragCompleted")]),t._v(" "),r("td",[t._v("组件被释放且被 "),r("a",{attrs:{href:""}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragStart")]),t._v(" "),r("td",[t._v("拖动开始时的回调函数")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"longpressdraggable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#longpressdraggable","aria-hidden":"true"}},[this._v("#")]),this._v(" LongPressDraggable")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"属性-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("hapticFeedbackOnStart")]),t._v(" "),r("td",[t._v("是否在拖动开始时触发触觉反馈")])]),t._v(" "),r("tr",[r("td",[t._v("affinity")]),t._v(" "),r("td",[t._v("控制此组件如何与其他手势竞争以启动拖动")])]),t._v(" "),r("tr",[r("td",[t._v("axis")]),t._v(" "),r("td",[t._v("如果指定，则限制拖动的轴向")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("包含的子组件")])]),t._v(" "),r("tr",[r("td",[t._v("childWhenDragging")]),t._v(" "),r("td",[t._v("拖动时显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("data")]),t._v(" "),r("td",[t._v("携带的数据")])]),t._v(" "),r("tr",[r("td",[t._v("dragAnchor")]),t._v(" "),r("td",[t._v("拖动时如何锚定此组件的位置")])]),t._v(" "),r("tr",[r("td",[t._v("feedback")]),t._v(" "),r("td",[t._v("拖动时指针下显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("feedbackOffset")]),t._v(" "),r("td",[t._v("可用于设置命中测试目标点，以便找到拖动目标。在 feedback 与 child 的相对位置改变时特别有用")])]),t._v(" "),r("tr",[r("td",[t._v("ignoringFeedbackSemantics")]),t._v(" "),r("td",[t._v("在构建语义树时是否忽略 feedback 组件的语义")])]),t._v(" "),r("tr",[r("td",[t._v("maxSimultaneousDrags")]),t._v(" "),r("td",[t._v("支持多少个同时拖动")])]),t._v(" "),r("tr",[r("td",[t._v("onDragCompleted")]),t._v(" "),r("td",[t._v("组件被释放且被 "),r("a",{attrs:{href:""}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragEnd")]),t._v(" "),r("td",[t._v("组件被释放时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDraggableCanceled")]),t._v(" "),r("td",[t._v("组件被释放但未被 "),r("a",{attrs:{href:""}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragStarted")]),t._v(" "),r("td",[t._v("拖动开始时的回调函数")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"gesturedetector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gesturedetector","aria-hidden":"true"}},[this._v("#")]),this._v(" GestureDetector")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("Material design 应用通常会对触摸作出具有墨水飞溅效果的反应。类 "),_("a",{attrs:{href:""}},[this._v("InkWell")]),this._v(" 实现了这种效果，并且可以用来代替 GestureDetector 处理点击。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"属性-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性-3","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("behavior")]),t._v(" "),r("td",[t._v("在命中测试期间，此手势检测器应如何表现")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("包含的子组件")])]),t._v(" "),r("tr",[r("td",[t._v("excludeFromSemantics")]),t._v(" "),r("td",[t._v("是否从语义树中排除这些手势。例如，长按显示 tooltip 被排除了，因为在语义树中 tooltip 自身已经包含了，因此如果手势中再去显示则会造成信息重复")])]),t._v(" "),r("tr",[r("td",[t._v("onDoubleTap")]),t._v(" "),r("td",[t._v("用户快速双击屏幕上相同位置两次时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragCancel")]),t._v(" "),r("td",[t._v("之前触发  "),r("a",{attrs:{href:""}},[t._v("onHorizontalDragDown")]),t._v(" 的指针未完成时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragDown")]),t._v(" "),r("td",[t._v("指针已接触屏幕，可能开始水平移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragEnd")]),t._v(" "),r("td",[t._v("先前与屏幕接触并且水平移动的指针不再与屏幕接触，并且当它停止接触屏幕时以特定速度移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragStart")]),t._v(" "),r("td",[t._v("指针已接触屏幕并开始水平移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onLongPress")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onLongPressUp")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanCancel")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanDown")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanEnd")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanStart")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"dragtarget"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dragtarget","aria-hidden":"true"}},[this._v("#")]),this._v(" DragTarget")])}],!1,null,null,null);v.options.__file="InteractionModels.md";_.default=v.exports}}]);