(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{164:function(t,_,r){"use strict";r.r(_);var v=r(0),e=Object(v.a)({},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),r("p",[t._v("在多点触控设备上，可以同时发生多次拖动，因为可能会有多个指针同时与设备接触。要限制同时拖动的数量，可以使用 maxSimultaneousDrags 属性。默认设置是允许无限数量的同时拖动。")]),t._v(" "),r("p",[t._v("当发生拖动时显示 child 中的组件。如果 childWhenDragging 非 null， 则显示 childWhenDragging 中的组件。")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),r("p",[t._v("长按使其子组件可以拖动。")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),r("p",[t._v("用于检测手势的组件。")]),t._v(" "),r("p",[t._v("会根据其非 null 的回调函数检测手势。")]),t._v(" "),r("p",[t._v("如果有子组件，则适应子组件的大小。否则，适应父组件的大小。")]),t._v(" "),r("p",[t._v("默认情况下，带有不可见子组件的 GestureDetector 会忽略触摸；可以通过 behavior 控制。")]),t._v(" "),r("p",[t._v("GestureDetector 也会监听辅助功能事件（accessibility events），并将它们映射到回调函数。要忽略辅助功能事件，可以将 excludeFromSemantics 设为 true。")]),t._v(" "),r("p",[t._v("有关其他信息，请参阅 "),r("a",{attrs:{href:"http://flutter.io/gestures/",target:"_blank",rel:"noopener noreferrer"}},[t._v("flutter.io/gestures/"),r("OutboundLink")],1),t._v("。")]),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),r("p",[t._v("当拖动 Draggable 到 DragTarget 上时，将询问 DragTarget 是否接收 Draggable 所携带的数据。如果用户确实将 Draggable 放在 DragTarget 上（并且 DragTarget 已指明它将接收 Draggable 的数据），则要求 DragTarget 接收 Draggable 的数据。")]),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19)])},[function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"draggable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#draggable","aria-hidden":"true"}},[this._v("#")]),this._v(" Draggable")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("可以在"),_("a",{attrs:{href:"#DragTarget"}},[this._v("DragTarget")]),this._v("中拖动的组件。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("当一个可拖动组件发生拖动时，它会显示一个在屏幕上跟踪用户手指的 feedback 组件。如果用在 "),_("a",{attrs:{href:""}},[this._v("DragTarget")]),this._v(" 组件上抬起手指，则该 "),_("a",{attrs:{href:""}},[this._v("DragTarget")]),this._v(" 可以选择接收 Draggable 组件携带的数据。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("affinity")]),t._v(" "),r("td",[t._v("控制此组件如何与其他手势竞争以启动拖动")])]),t._v(" "),r("tr",[r("td",[t._v("axis")]),t._v(" "),r("td",[t._v("如果指定，则限制拖动的轴向")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("包含的子组件")])]),t._v(" "),r("tr",[r("td",[t._v("childWhenDragging")]),t._v(" "),r("td",[t._v("拖动时显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("data")]),t._v(" "),r("td",[t._v("携带的数据")])]),t._v(" "),r("tr",[r("td",[t._v("dragAnchor")]),t._v(" "),r("td",[t._v("拖动时如何锚定此组件的位置")])]),t._v(" "),r("tr",[r("td",[t._v("feedback")]),t._v(" "),r("td",[t._v("拖动时指针下显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("feedbackOffset")]),t._v(" "),r("td",[t._v("可用于设置命中测试目标点，以便找到拖动目标。在 feedback 与 child 的相对位置改变时特别有用")])]),t._v(" "),r("tr",[r("td",[t._v("ignoringFeedbackSemantics")]),t._v(" "),r("td",[t._v("在构建语义树时是否忽略 feedback 组件的语义")])]),t._v(" "),r("tr",[r("td",[t._v("maxSimultaneousDrags")]),t._v(" "),r("td",[t._v("支持多少个同时拖动")])]),t._v(" "),r("tr",[r("td",[t._v("onDragCompleted")]),t._v(" "),r("td",[t._v("组件被释放且被 "),r("a",{attrs:{href:""}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragStart")]),t._v(" "),r("td",[t._v("拖动开始时的回调函数")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"longpressdraggable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#longpressdraggable","aria-hidden":"true"}},[this._v("#")]),this._v(" LongPressDraggable")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"属性-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("hapticFeedbackOnStart")]),t._v(" "),r("td",[t._v("是否在拖动开始时触发触觉反馈")])]),t._v(" "),r("tr",[r("td",[t._v("affinity")]),t._v(" "),r("td",[t._v("控制此组件如何与其他手势竞争以启动拖动")])]),t._v(" "),r("tr",[r("td",[t._v("axis")]),t._v(" "),r("td",[t._v("如果指定，则限制拖动的轴向")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("包含的子组件")])]),t._v(" "),r("tr",[r("td",[t._v("childWhenDragging")]),t._v(" "),r("td",[t._v("拖动时显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("data")]),t._v(" "),r("td",[t._v("携带的数据")])]),t._v(" "),r("tr",[r("td",[t._v("dragAnchor")]),t._v(" "),r("td",[t._v("拖动时如何锚定此组件的位置")])]),t._v(" "),r("tr",[r("td",[t._v("feedback")]),t._v(" "),r("td",[t._v("拖动时指针下显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("feedbackOffset")]),t._v(" "),r("td",[t._v("可用于设置命中测试目标点，以便找到拖动目标。在 feedback 与 child 的相对位置改变时特别有用")])]),t._v(" "),r("tr",[r("td",[t._v("ignoringFeedbackSemantics")]),t._v(" "),r("td",[t._v("在构建语义树时是否忽略 feedback 组件的语义")])]),t._v(" "),r("tr",[r("td",[t._v("maxSimultaneousDrags")]),t._v(" "),r("td",[t._v("支持多少个同时拖动")])]),t._v(" "),r("tr",[r("td",[t._v("onDragCompleted")]),t._v(" "),r("td",[t._v("组件被释放且被 "),r("a",{attrs:{href:""}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragEnd")]),t._v(" "),r("td",[t._v("组件被释放时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDraggableCanceled")]),t._v(" "),r("td",[t._v("组件被释放但未被 "),r("a",{attrs:{href:""}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragStarted")]),t._v(" "),r("td",[t._v("拖动开始时的回调函数")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"gesturedetector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gesturedetector","aria-hidden":"true"}},[this._v("#")]),this._v(" GestureDetector")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("Material design 应用通常会对触摸作出具有墨水飞溅效果的反应。类 "),_("a",{attrs:{href:""}},[this._v("InkWell")]),this._v(" 实现了这种效果，并且可以用来代替 GestureDetector 处理点击。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"属性-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性-3","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("behavior")]),t._v(" "),r("td",[t._v("在命中测试期间，此手势检测器应如何表现")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("包含的子组件")])]),t._v(" "),r("tr",[r("td",[t._v("excludeFromSemantics")]),t._v(" "),r("td",[t._v("是否从语义树中排除这些手势。例如，长按显示 tooltip 被排除了，因为在语义树中 tooltip 自身已经包含了，因此如果手势中再去显示则会造成信息重复")])]),t._v(" "),r("tr",[r("td",[t._v("onDoubleTap")]),t._v(" "),r("td",[t._v("用户快速双击屏幕上相同位置两次时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragCancel")]),t._v(" "),r("td",[t._v("之前触发 onHorizontalDragDown 的指针未完成时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragDown")]),t._v(" "),r("td",[t._v("指针已接触屏幕，可能开始水平移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragEnd")]),t._v(" "),r("td",[t._v("先前与屏幕接触并且水平移动的指针不再与屏幕接触，并且当它停止接触屏幕时以特定速度移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragStart")]),t._v(" "),r("td",[t._v("指针已接触屏幕并开始水平移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onLongPress")]),t._v(" "),r("td",[t._v("指针长时间保持与屏幕相同位置接触时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onLongPressUp")]),t._v(" "),r("td",[t._v("触发长按的指针已停止接触屏幕时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanCancel")]),t._v(" "),r("td",[t._v("先前触发 onPanDown 的指针未完成时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanDown")]),t._v(" "),r("td",[t._v("指针已接触屏幕并可能开始移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanEnd")]),t._v(" "),r("td",[t._v("先前与屏幕接触并移动的指针不再与屏幕接触，并且当它停止接触屏幕时以特定速度移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanStart")]),t._v(" "),r("td",[t._v("指针已经接触屏幕并开始移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触并移动的指针再次移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onScaleEnd")]),t._v(" "),r("td",[t._v("指针不再与屏幕接触时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onScaleStart")]),t._v(" "),r("td",[t._v("与屏幕接触的指针已建立焦点，且初始比例为 1.0 时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onScaleUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触的指针指示了新的焦点和/或缩放时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onTap")]),t._v(" "),r("td",[t._v("点击时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onTapCancel")]),t._v(" "),r("td",[t._v("先前触发 onTapDown 的指针不会导致点击时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onTapDown")]),t._v(" "),r("td",[t._v("可能导致点击的指针已在特定位置与屏幕接触时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onTapUp")]),t._v(" "),r("td",[t._v("将触发敲击的指针已停止在特定位置与屏幕接触时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragCancel")]),t._v(" "),r("td",[t._v("先前触发 onVerticalDragDown 的指针未完成时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragDown")]),t._v(" "),r("td",[t._v("指针已接触屏幕，可能会开始垂直移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragEnd")]),t._v(" "),r("td",[t._v("之前与屏幕接触并垂直移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragStart")]),t._v(" "),r("td",[t._v("指针已接触屏幕并已开始垂直移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触并垂直移动的指针在垂直方向上移动时的回调函数")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法","aria-hidden":"true"}},[this._v("#")]),this._v(" 方法")])},function(){var t=this.$createElement,_=this._self._c||t;return _("table",[_("thead",[_("tr",[_("th",[this._v("名称")]),this._v(" "),_("th",[this._v("功能")])])]),this._v(" "),_("tbody",[_("tr",[_("td",[this._v("build")]),this._v(" "),_("td",[this._v("构建此组件的 UI")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"dragtarget"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dragtarget","aria-hidden":"true"}},[this._v("#")]),this._v(" DragTarget")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("释放 "),_("a",{attrs:{href:"#Draggable"}},[this._v("Draggable")]),this._v(" 时可以接收其数据。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"属性-4"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性-4","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("builder")]),t._v(" "),r("td",[t._v("用于构建此组件的内容")])]),t._v(" "),r("tr",[r("td",[t._v("onAccept")]),t._v(" "),r("td",[t._v("当在此组件上放置可接收的数据时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onLeave")]),t._v(" "),r("td",[t._v("当在此组件上拖动的给定数据离开时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onWillAccept")]),t._v(" "),r("td",[t._v("确定是否接收拖入此组件上的组件的给定数据")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"方法-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 方法")])},function(){var t=this.$createElement,_=this._self._c||t;return _("table",[_("thead",[_("tr",[_("th",[this._v("名称")]),this._v(" "),_("th",[this._v("功能")])])]),this._v(" "),_("tbody",[_("tr",[_("td",[this._v("createState")]),this._v(" "),_("td",[this._v("在树中的给定位置为此组件创建可变状态")])])])])}],!1,null,null,null);e.options.__file="InteractionModels.md";_.default=e.exports}}]);