(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{165:function(t,e,r){"use strict";r.r(e);var _=r(0),v=Object(_.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),r("p",[t._v("在多点触控设备上，可以同时发生多次拖动，因为可能会有多个指针同时与设备接触。要限制同时拖动的数量，可以使用 maxSimultaneousDrags 属性。默认设置是允许无限数量的同时拖动。")]),t._v(" "),r("p",[t._v("当发生拖动时显示 child 中的组件。如果 childWhenDragging 非 null， 则显示 childWhenDragging 中的组件。")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),r("p",[t._v("长按使其子组件可以拖动。")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),r("p",[t._v("用于检测手势的组件。")]),t._v(" "),r("p",[t._v("会根据其非 null 的回调函数检测手势。")]),t._v(" "),r("p",[t._v("如果有子组件，则适应子组件的大小。否则，适应父组件的大小。")]),t._v(" "),r("p",[t._v("默认情况下，带有不可见子组件的 GestureDetector 会忽略触摸；可以通过 behavior 控制。")]),t._v(" "),r("p",[t._v("GestureDetector 也会监听辅助功能事件（accessibility events），并将它们映射到回调函数。要忽略辅助功能事件，可以将 excludeFromSemantics 设为 true。")]),t._v(" "),r("p",[t._v("有关其他信息，请参阅 "),r("a",{attrs:{href:"http://flutter.io/gestures/",target:"_blank",rel:"noopener noreferrer"}},[t._v("flutter.io/gestures/"),r("OutboundLink")],1),t._v("。")]),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),r("p",[t._v("当拖动 Draggable 到 DragTarget 上时，将询问 DragTarget 是否接收 Draggable 所携带的数据。如果用户确实将 Draggable 放在 DragTarget 上（并且 DragTarget 已指明它将接收 Draggable 的数据），则要求 DragTarget 接收 Draggable 的数据。")]),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),r("p",[t._v("在指定方向上拖动时可以移除的组件。")]),t._v(" "),r("p",[t._v("在 DismissDirection 中拖动或滑动此组件将使其 child 滑出视图。跟随滑动动画，如果 resizeDuration 不为 null，则此组件将其高度（与移除方向垂直时为宽度，）以动画的形式从 resizeDuration 减至 0。")]),t._v(" "),r("p",[t._v("background 可以实现“遗留”效果。如果指定了 background，则它会堆叠在 Dismissible 的 child 之后，并在 child 移动时显露出来。")]),t._v(" "),r("p",[t._v("此组件在其大小折叠为 0（如果 resizeDuration 非 null）之后或在滑动动画之后立即（如果 resizeDuration 为 null）调用 onDismissed 回调函数。如果 Dismissible 是一个列表项，它必须有一个键以区别于其他项，并且它的 onDismissed 回调函数必须从列表中删除该项。")]),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),r("p",[t._v("在命中测试期间不可见的组件。")]),t._v(" "),r("p",[t._v("如果 ignoring 为 true，则此组件（及其子树）对于命中测试是不可见的。它仍然会在布局过程中消耗空间并像往常一样绘制 child。它只是不能成为定位事件的目标，因为它从 RenderBox.hitTest 返回 false。")]),t._v(" "),r("p",[t._v("当 ignoringSemantics 为 true 时，子树对于语义层是不可见的（因此，例如可访问性工具）。如果 ignoringSemantics 为 null，则它使用 ignoring 的值。")]),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),r("p",[t._v("在命中测试期间吸收指针的组件。")]),t._v(" "),r("p",[t._v("当 absorbing 为 true 时，此组件通过终止命中测试来阻止其子树接收指针事件。它仍然会在布局过程中消耗空间并像往常一样绘制 child。它只是阻止其子节点成为定位事件的目标，因为它从 RenderBox.hitTest 返回 true。")]),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),r("p",[t._v("可以滚动的组件。")]),t._v(" "),r("p",[t._v("Scrollable 实现可滚动组件的交互模型，包括手势识别，但没有关于如何构造实际显示子组件的视口的信息。")]),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),r("p",[t._v("要使用 Scrollable 进一步自定义滚动行为：")]),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"draggable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#draggable","aria-hidden":"true"}},[this._v("#")]),this._v(" Draggable")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("可以在 "),e("a",{attrs:{href:"#dragtarget"}},[this._v("DragTarget")]),this._v(" 中拖动的组件。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当一个可拖动组件发生拖动时，它会显示一个在屏幕上跟踪用户手指的 feedback 组件。如果用在 "),e("a",{attrs:{href:"#dragtarget"}},[this._v("DragTarget")]),this._v(" 组件上抬起手指，则该 "),e("a",{attrs:{href:"#dragtarget"}},[this._v("DragTarget")]),this._v(" 可以选择接收 Draggable 组件携带的数据。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("affinity")]),t._v(" "),r("td",[t._v("控制此组件如何与其他手势竞争以启动拖动")])]),t._v(" "),r("tr",[r("td",[t._v("axis")]),t._v(" "),r("td",[t._v("如果指定，则限制拖动的轴向")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("子组件")])]),t._v(" "),r("tr",[r("td",[t._v("childWhenDragging")]),t._v(" "),r("td",[t._v("拖动时显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("data")]),t._v(" "),r("td",[t._v("携带的数据")])]),t._v(" "),r("tr",[r("td",[t._v("dragAnchor")]),t._v(" "),r("td",[t._v("拖动时如何锚定此组件的位置")])]),t._v(" "),r("tr",[r("td",[t._v("feedback")]),t._v(" "),r("td",[t._v("拖动时指针下显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("feedbackOffset")]),t._v(" "),r("td",[t._v("可用于设置命中测试目标点，以便找到拖动目标。在 feedback 与 child 的相对位置改变时特别有用")])]),t._v(" "),r("tr",[r("td",[t._v("ignoringFeedbackSemantics")]),t._v(" "),r("td",[t._v("在构建语义树时是否忽略 feedback 组件的语义")])]),t._v(" "),r("tr",[r("td",[t._v("maxSimultaneousDrags")]),t._v(" "),r("td",[t._v("支持多少个同时拖动")])]),t._v(" "),r("tr",[r("td",[t._v("onDragCompleted")]),t._v(" "),r("td",[t._v("组件被释放且被 "),r("a",{attrs:{href:"#dragtarget"}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragStart")]),t._v(" "),r("td",[t._v("拖动开始时的回调函数")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"longpressdraggable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#longpressdraggable","aria-hidden":"true"}},[this._v("#")]),this._v(" LongPressDraggable")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"属性-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("hapticFeedbackOnStart")]),t._v(" "),r("td",[t._v("是否在拖动开始时触发触觉反馈")])]),t._v(" "),r("tr",[r("td",[t._v("affinity")]),t._v(" "),r("td",[t._v("控制此组件如何与其他手势竞争以启动拖动")])]),t._v(" "),r("tr",[r("td",[t._v("axis")]),t._v(" "),r("td",[t._v("如果指定，则限制拖动的轴向")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("子组件")])]),t._v(" "),r("tr",[r("td",[t._v("childWhenDragging")]),t._v(" "),r("td",[t._v("拖动时显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("data")]),t._v(" "),r("td",[t._v("携带的数据")])]),t._v(" "),r("tr",[r("td",[t._v("dragAnchor")]),t._v(" "),r("td",[t._v("拖动时如何锚定此组件的位置")])]),t._v(" "),r("tr",[r("td",[t._v("feedback")]),t._v(" "),r("td",[t._v("拖动时指针下显示的组件")])]),t._v(" "),r("tr",[r("td",[t._v("feedbackOffset")]),t._v(" "),r("td",[t._v("可用于设置命中测试目标点，以便找到拖动目标。在 feedback 与 child 的相对位置改变时特别有用")])]),t._v(" "),r("tr",[r("td",[t._v("ignoringFeedbackSemantics")]),t._v(" "),r("td",[t._v("在构建语义树时是否忽略 feedback 组件的语义")])]),t._v(" "),r("tr",[r("td",[t._v("maxSimultaneousDrags")]),t._v(" "),r("td",[t._v("支持多少个同时拖动")])]),t._v(" "),r("tr",[r("td",[t._v("onDragCompleted")]),t._v(" "),r("td",[t._v("组件被释放且被 "),r("a",{attrs:{href:"#dragtarget"}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragEnd")]),t._v(" "),r("td",[t._v("组件被释放时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDraggableCanceled")]),t._v(" "),r("td",[t._v("组件被释放但未被 "),r("a",{attrs:{href:"#dragtarget"}},[t._v("DragTarget")]),t._v(" 接收时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onDragStarted")]),t._v(" "),r("td",[t._v("拖动开始时的回调函数")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"gesturedetector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gesturedetector","aria-hidden":"true"}},[this._v("#")]),this._v(" GestureDetector")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Material design 应用通常会对触摸作出具有墨水飞溅效果的反应。类 "),e("a",{attrs:{href:""}},[this._v("InkWell")]),this._v(" 实现了这种效果，并且可以用来代替 GestureDetector 处理点击。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"属性-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-3","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("behavior")]),t._v(" "),r("td",[t._v("在命中测试期间，此手势检测器应如何表现")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("子组件")])]),t._v(" "),r("tr",[r("td",[t._v("excludeFromSemantics")]),t._v(" "),r("td",[t._v("是否从语义树中排除这些手势。例如，长按显示 tooltip 被排除了，因为在语义树中 tooltip 自身已经包含了，因此如果手势中再去显示则会造成信息重复")])]),t._v(" "),r("tr",[r("td",[t._v("onDoubleTap")]),t._v(" "),r("td",[t._v("用户快速双击屏幕上相同位置两次时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragCancel")]),t._v(" "),r("td",[t._v("之前触发 onHorizontalDragDown 的指针未完成时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragDown")]),t._v(" "),r("td",[t._v("指针已接触屏幕，可能开始水平移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragEnd")]),t._v(" "),r("td",[t._v("先前与屏幕接触并且水平移动的指针不再与屏幕接触，并且当它停止接触屏幕时以特定速度移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragStart")]),t._v(" "),r("td",[t._v("指针已接触屏幕并开始水平移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onHorizontalDragUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触并水平移动的指针在水平方向上移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onLongPress")]),t._v(" "),r("td",[t._v("指针长时间保持与屏幕相同位置接触时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onLongPressUp")]),t._v(" "),r("td",[t._v("触发长按的指针已停止接触屏幕时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanCancel")]),t._v(" "),r("td",[t._v("先前触发 onPanDown 的指针未完成时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanDown")]),t._v(" "),r("td",[t._v("指针已接触屏幕并可能开始移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanEnd")]),t._v(" "),r("td",[t._v("先前与屏幕接触并移动的指针不再与屏幕接触，并且当它停止接触屏幕时以特定速度移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanStart")]),t._v(" "),r("td",[t._v("指针已经接触屏幕并开始移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onPanUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触并移动的指针再次移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onScaleEnd")]),t._v(" "),r("td",[t._v("指针不再与屏幕接触时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onScaleStart")]),t._v(" "),r("td",[t._v("与屏幕接触的指针已建立焦点，且初始比例为 1.0 时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onScaleUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触的指针指示了新的焦点和/或缩放时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onTap")]),t._v(" "),r("td",[t._v("点击时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onTapCancel")]),t._v(" "),r("td",[t._v("先前触发 onTapDown 的指针不会导致点击时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onTapDown")]),t._v(" "),r("td",[t._v("可能导致点击的指针已在特定位置与屏幕接触时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onTapUp")]),t._v(" "),r("td",[t._v("将触发敲击的指针已停止在特定位置与屏幕接触时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragCancel")]),t._v(" "),r("td",[t._v("先前触发 onVerticalDragDown 的指针未完成时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragDown")]),t._v(" "),r("td",[t._v("指针已接触屏幕，可能会开始垂直移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragEnd")]),t._v(" "),r("td",[t._v("之前与屏幕接触并垂直移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragStart")]),t._v(" "),r("td",[t._v("指针已接触屏幕并已开始垂直移动时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onVerticalDragUpdate")]),t._v(" "),r("td",[t._v("与屏幕接触并垂直移动的指针在垂直方向上移动时的回调函数")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法","aria-hidden":"true"}},[this._v("#")]),this._v(" 方法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("table",[e("thead",[e("tr",[e("th",[this._v("名称")]),this._v(" "),e("th",[this._v("功能")])])]),this._v(" "),e("tbody",[e("tr",[e("td",[this._v("build")]),this._v(" "),e("td",[this._v("构建此组件的 UI")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"dragtarget"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dragtarget","aria-hidden":"true"}},[this._v("#")]),this._v(" DragTarget")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("释放 "),e("a",{attrs:{href:"#draggable"}},[this._v("Draggable")]),this._v(" 时可以接收其数据。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"属性-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-4","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("builder")]),t._v(" "),r("td",[t._v("用于构建此组件的内容")])]),t._v(" "),r("tr",[r("td",[t._v("onAccept")]),t._v(" "),r("td",[t._v("当在此组件上放置可接收的数据时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onLeave")]),t._v(" "),r("td",[t._v("当在此组件上拖动的给定数据离开时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onWillAccept")]),t._v(" "),r("td",[t._v("确定是否接收拖入此组件上的组件的给定数据")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"方法-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 方法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("table",[e("thead",[e("tr",[e("th",[this._v("名称")]),this._v(" "),e("th",[this._v("功能")])])]),this._v(" "),e("tbody",[e("tr",[e("td",[this._v("createState")]),this._v(" "),e("td",[this._v("在树中的给定位置为此组件创建可变状态")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"dismissible"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dismissible","aria-hidden":"true"}},[this._v("#")]),this._v(" Dismissible")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"属性-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-5","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("background")]),t._v(" "),r("td",[t._v("放在 child 后面的组件。如果还指定了secondaryBackground，则只有在向下或向右拖动 child 时才会显示此组件。")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("子组件")])]),t._v(" "),r("tr",[r("td",[t._v("crossAxisEndOffset")]),t._v(" "),r("td",[t._v("定义在卡片被移除后主轴上的结束偏移量")])]),t._v(" "),r("tr",[r("td",[t._v("direction")]),t._v(" "),r("td",[t._v("可以移除组件的方向")])]),t._v(" "),r("tr",[r("td",[t._v("dismissThresholds")]),t._v(" "),r("td",[t._v("移除组件所需的偏移阈值")])]),t._v(" "),r("tr",[r("td",[t._v("movementDuration")]),t._v(" "),r("td",[t._v("定义移除卡片（或如果不移除返回原始位置）的持续时间")])]),t._v(" "),r("tr",[r("td",[t._v("onDismissed")]),t._v(" "),r("td",[t._v("完成大小调整后，在组件被移除时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("onResize")]),t._v(" "),r("td",[t._v("组件大小改变（被移除之前）时的回调函数")])]),t._v(" "),r("tr",[r("td",[t._v("resizeDuration")]),t._v(" "),r("td",[t._v("onDismissed 调用之前持续的总时间")])]),t._v(" "),r("tr",[r("td",[t._v("secondaryBackground")]),t._v(" "),r("td",[t._v("堆叠在 child 后面，当 child 被向上或向左拖动时会显露出来。只有在指定了 background 时才可以指定它")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"方法-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法-3","aria-hidden":"true"}},[this._v("#")]),this._v(" 方法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("table",[e("thead",[e("tr",[e("th",[this._v("名称")]),this._v(" "),e("th",[this._v("功能")])])]),this._v(" "),e("tbody",[e("tr",[e("td",[this._v("createState")]),this._v(" "),e("td",[this._v("在树中的给定位置为此组件创建可变状态")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"ignorepointer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ignorepointer","aria-hidden":"true"}},[this._v("#")]),this._v(" IgnorePointer")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"属性-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-6","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("ignoring")]),t._v(" "),r("td",[t._v("命中检测期间是否忽略此组件")])]),t._v(" "),r("tr",[r("td",[t._v("ignoringSemantics")]),t._v(" "),r("td",[t._v("编译语义树时是否忽略此组件的语义")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("子组件")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"方法-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法-4","aria-hidden":"true"}},[this._v("#")]),this._v(" 方法")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("名称")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("createRenderObject")]),t._v(" "),r("td",[t._v("使用此 RenderObjectWidget 描述的配置创建此 RenderObjectWidget 表示的 RenderObject 的实例")])]),t._v(" "),r("tr",[r("td",[t._v("debugFillProperties")]),t._v(" "),r("td",[t._v("添加与节点关联的额外属性")])]),t._v(" "),r("tr",[r("td",[t._v("updateRenderObject")]),t._v(" "),r("td",[t._v("将此 RenderObjectWidget 描述的配置复制到给定的 RenderObject，该类型与此对象的 createRenderObject 返回的类型相同")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"absorbpointer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#absorbpointer","aria-hidden":"true"}},[this._v("#")]),this._v(" AbsorbPointer")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"属性-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-7","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("absorbing")]),t._v(" "),r("td",[t._v("命中检测期间是否吸收指针")])]),t._v(" "),r("tr",[r("td",[t._v("ignoringSemantics")]),t._v(" "),r("td",[t._v("编译语义树时是否忽略此组件的语义")])]),t._v(" "),r("tr",[r("td",[t._v("child")]),t._v(" "),r("td",[t._v("子组件")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"scrollable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scrollable","aria-hidden":"true"}},[this._v("#")]),this._v(" Scrollable")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("很难直接构造 Scrollable。请考虑使用 "),e("a",{attrs:{href:""}},[this._v("ListView")]),this._v(" 或 "),e("a",{attrs:{href:""}},[this._v("GridView")]),this._v("，它们结合了滚动，视口和布局模型。要组合布局模型（或使用自定义布局模式），请考虑使用  "),e("a",{attrs:{href:""}},[this._v("CustomScrollView")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("静态 Scrollable.of 和 Scrollable.ensureVisible 函数通常用于与 "),e("a",{attrs:{href:""}},[this._v("ListView")]),this._v(" 或 "),e("a",{attrs:{href:""}},[this._v("GridView")]),this._v(" 中的 Scrollable 组件进行交互。")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",[r("li",[r("p",[t._v("你可以提供 viewportBuilder 来自定义子模型。例如，"),r("a",{attrs:{href:""}},[t._v("SingleChildScrollView")]),t._v(" 使用显示单个 box 子视图的视口，而 "),r("a",{attrs:{href:""}},[t._v("CustomScrollView")]),t._v(" 使用 "),r("a",{attrs:{href:""}},[t._v("Viewport")]),t._v(" 或 "),r("a",{attrs:{href:""}},[t._v("ShrinkWrappingViewport")]),t._v("，两者都显示 slivers 列表。")])]),t._v(" "),r("li",[r("p",[t._v("你可以提供自定义 "),r("a",{attrs:{href:""}},[t._v("ScrollController")]),t._v("，以创建自定义 "),r("a",{attrs:{href:""}},[t._v("ScrollPosition")]),t._v(" 子类。例如，"),r("a",{attrs:{href:""}},[t._v("PageView")]),t._v(" 使用 "),r("a",{attrs:{href:""}},[t._v("PageController")]),t._v("，它创建一个面向页面的滚动位置子类，以在 Scrollable 调整大小时保持同一页面可见。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"属性-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-8","aria-hidden":"true"}},[this._v("#")]),this._v(" 属性")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("属性")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("axis")]),t._v(" "),r("td",[t._v("滚动视图的滚动轴向")])]),t._v(" "),r("tr",[r("td",[t._v("axisDirection")]),t._v(" "),r("td",[t._v("组件的滚动方向")])]),t._v(" "),r("tr",[r("td",[t._v("controller")]),t._v(" "),r("td",[t._v("可用于控制滚动此组件位置的对象")])]),t._v(" "),r("tr",[r("td",[t._v("excludeFromSemantics")]),t._v(" "),r("td",[t._v("此 Scrollable 引入的滚动操作是否在语义树中显露")])]),t._v(" "),r("tr",[r("td",[t._v("physics")]),t._v(" "),r("td",[t._v("组件应如何响应用户输入")])]),t._v(" "),r("tr",[r("td",[t._v("viewportBuilder")]),t._v(" "),r("td",[t._v("构建可通过其显示可滚动内容的视口")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"方法-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法-5","aria-hidden":"true"}},[this._v("#")]),this._v(" 方法")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("名称")]),t._v(" "),r("th",[t._v("功能")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("createState")]),t._v(" "),r("td",[t._v("在树中的给定位置为此组件创建可变状态")])]),t._v(" "),r("tr",[r("td",[t._v("debugFillProperties")]),t._v(" "),r("td",[t._v("添加与节点关联的额外属性")])])])])}],!1,null,null,null);v.options.__file="InteractionModels.md";e.default=v.exports}}]);